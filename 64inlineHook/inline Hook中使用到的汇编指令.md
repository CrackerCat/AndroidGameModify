# armconverter
```
ARM架构的机器码和汇编指令的相互转换
https://armconverter.com/
```
# inline Hook中用到的汇编指令
- 两种Hook方式介绍
```
1、函数替换的方式
指直接跳转到目标函数，不需要再跳转回来。

2、函数附加的方式
指需要执行函数的原始逻辑，跳转到自定义函数地址后，还需要跳转回来。
这就需要寄存器来保存原始的参数，以便跳转回原始的函数的时候，有参数可以继续执行原始函数。

如果只在单个so文件中进行跳转，使用b指令就足够了。
如果要跨so文件进行跳转，那么b指令所能表达的位数不足以支持它进行文件间的跳转操作，这时需要使用br指令。
选择指令后，需要保存待跳转函数的地址，这时需要在各个寄存器之间进行选择。
通过比较x0~x31寄存器的功能，最终选择x16~x18作为跳板寄存器。
```

- 定向跳转
```
定向跳转常用的是b系列指令，如b指令、bl指令、br指令、blr指令。
b：跳转到相对地址
bl：跳转到相对地址并处理x30寄存器
br：跳转到绝对地址，是参数位寄存器
blr：跳转到绝对地址并处理x30寄存器

1、b指令
b指令有位的大小限制，不能跳转太远，所以它只适合在单个so文件之内跳转，如果需要做跨so文件的跳转，b指令就有它的局限性。
如果想Hook art函数，一定不可以使用b指令来Hook。

2、bl指令
bl指令只是处理了x30寄存器，而且我们也不需要处理x30寄存器，所以它也不能进行Hook art函数的操作，同b指令一样，它表达的位数太短了。

3、br指令
br指令可以跳转到寄存器的位置，所以br指令可以做到Hook art函数。

4、blr指令
函数的替换一定要使用return指令，那么x30寄存器就要保存下来，因为x30寄存器中保存着函数的返回值。
使用blr指令就要处理x30寄存器，所以它不能Hook art函数。
```

- 寄存器保存
```
1、寄存器的选择
x0~x7：传递子程序的参数和返回值，使用时不需要保存，多余的参数使用堆栈传递，64位的返回结果保存到x0中。
x8：用于保存子程序的返回地址，使用时不需要保存。
x9~x15：临时寄存器，也叫可变寄存器，子程序使用时不需要保存。
x16~x17：子程序内部调用寄存器（IPx），使用时不需要保存，尽量不要使用。
x18：平台寄存器，它的使用与平台相关，尽量不要使用。
x19~x28：临时寄存器，子程序使用时必须保存。
x29：帧指针寄存器（FR），用于连接栈帧，使用时必须保存。
x30：链接寄存器（LR），用于保存子程序的返回地址。
x31：堆栈指针寄存器（SP），用于指向每个函数的栈顶。

x0~x7是不可以动的，这些寄存器中保存的是原始函数的参数和返回值，如果改变了这些寄存器，那么做Hook就没有意义了。
x9~x15是临时寄存器，从它们的功能来看是可以使用的，如果进行inline Hook，可以不在函数的开头Hook，在中间的某一段Hook即可。

我们能使用的就是x16~x18寄存器。
x16、x17在PLT Hook中会用到，在LLVM中，x16、x17寄存器可以做一些传值的处理。
唯一没有使用的是x18寄存器，它是一个平台寄存器，如果不是LLVM，那么就使用x16、x17寄存器，否则使用x18寄存器。

2、3种寄存器赋值的方案
MOV
小位赋值，它可以给寄存器赋值，但是一旦赋值位数变长，它就会越界。

ADRP
使用ADRP的方式需要对页进行对齐，所以也不可行。

LDR
LDR赋值方式为LDR x16,4，4代表偏移。
将当前地址偏移4之后，地址中的数据存到寄存器x16中。
```

```
选择正确的指令、寄存器以及赋值方案后，就可以编码进行跳转

int code1 = 0x50000058; // ldr x16, #8
int code2 = 0xdf160200; // br x16
long code3 = reinterpret_cast<long>(myreplace); // 待跳转的地址

// 将code1 code2 code3分别赋值给需要Hook的函数的前三条指令
*(int*)((char*)loadMethod) = code1;
*(int*)((char*)loadMethod +4) = code1;
*(int*)((char*)loadMethod +8) = code1;
```
